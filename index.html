<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phonics Flying: è½éŸ³é«”æ„Ÿå°„æ“Š (ä¿®æ­£ç‰ˆ)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@500;700&display=swap');

        body {
            margin: 0;
            background-color: #1a1a2e;
            background-image: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
            overflow: hidden;
            font-family: 'Fredoka', 'Noto Sans TC', sans-serif;
            user-select: none;
        }
        
        /* [ä¿®æ­£é‡é» 1] ä¸è¦ä½¿ç”¨ display: noneï¼Œæ”¹ç”¨é€æ˜åº¦éš±è—ï¼Œç¢ºä¿ä¸²æµæŒçºŒé‹ä½œ */
        #video {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0; 
            z-index: -1;
            width: 1px;
            height: 1px;
            pointer-events: none;
        }

        canvas {
            position: absolute;
            top: 0; left: 0;
            transform: scaleX(-1); /* é¡åƒç¿»è½‰ */
        }
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }
        
        .hud-bar {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 30px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            gap: 40px;
            color: white;
            font-size: 24px;
            z-index: 10;
        }

        .footer-credit {
            margin-bottom: 20px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 500;
        }

        #speaker-icon {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 80px;
            opacity: 0.5;
            transition: 0.2s;
            text-shadow: 0 0 20px #fff;
            z-index: 5;
        }
        .speaking {
            animation: pulse-speaker 0.5s infinite alternate;
            color: #00ffcc;
            opacity: 1 !important;
        }

        @keyframes pulse-speaker {
            from { transform: translate(-50%, -50%) scale(1); text-shadow: 0 0 10px #00ffcc; }
            to { transform: translate(-50%, -50%) scale(1.2); text-shadow: 0 0 30px #00ffcc; }
        }

        #start-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(26, 26, 46, 0.95);
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        h1 {
            font-size: 60px;
            margin-bottom: 5px;
            background: linear-gradient(to right, #4facfe, #00f2fe);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 30px rgba(0, 242, 254, 0.3);
        }

        .producer-title {
            font-size: 24px;
            color: #ddd;
            margin-bottom: 30px;
            letter-spacing: 2px;
        }

        button {
            margin-top: 30px;
            padding: 15px 50px;
            font-size: 24px;
            font-family: 'Fredoka', sans-serif;
            background: #4facfe;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
            transition: 0.2s;
        }
        button:hover {
            transform: scale(1.05);
            background: #00f2fe;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-bar">
            <div id="score-display">Score: 0</div>
            <div id="streak-display">Streak: 0</div>
        </div>
        
        <div id="speaker-icon">ğŸ”Š</div>

        <div class="footer-credit">å°ç£å…’ç«¥ç¾èªå”æœƒè£½ä½œ</div>
    </div>

    <div id="start-screen">
        <h1>Phonics Flying</h1>
        <div class="producer-title">å°ç£å…’ç«¥ç¾èªå”æœƒè£½ä½œ</div>
        <div style="margin: 20px; text-align: center; color: #aaa; font-size: 18px;">
            <p>ğŸ‘‚ ä»”ç´°è½ç™¼éŸ³</p>
            <p>ğŸˆ æ“Šç ´æ­£ç¢ºçš„é£›å¤©æ°£æ³¡</p>
            <p>âš¡ é€Ÿåº¦è¦å¿«ï¼Œæ°£æ³¡æœƒæ‰å…‰å–”ï¼</p>
        </div>
        <button id="startBtn">Start Game</button>
        <p id="loading-text" style="margin-top: 15px; font-size: 14px; color: #666; max-width: 80%;">è«‹é»æ“Šé–‹å§‹ï¼Œä¸¦å…è¨±æ”å½±æ©Ÿæ¬Šé™...</p>
    </div>

    <video id="video" playsinline></video>
    <canvas id="output"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        const videoElement = document.getElementById('video');
        const canvasElement = document.getElementById('output');
        const ctx = canvasElement.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('startBtn');
        const speakerIcon = document.getElementById('speaker-icon');
        const scoreDisplay = document.getElementById('score-display');
        const streakDisplay = document.getElementById('streak-display');
        const loadingText = document.getElementById('loading-text');

        let width, height;
        let gameActive = false;
        let score = 0;
        let streak = 0;
        
        const wordTriplets = [
            ["Cat", "Cut", "Cot"],      
            ["Pen", "Pan", "Pin"],      
            ["Bad", "Bed", "Bud"],      
            ["Sit", "Seat", "Set"],     
            ["Look", "Luke", "Luck"],   
            ["Hat", "Hot", "Hut"],      
            ["Fan", "Van", "Than"],     
            ["Ship", "Sheep", "Chip"],  
            ["Wait", "Wet", "White"],   
            ["Tail", "Tall", "Tell"]    
        ];

        let currentTargetWord = null;
        let isSpeaking = false;
        let canAnswer = false; 

        function speakWord(word) {
            window.speechSynthesis.cancel();
            isSpeaking = true;
            canAnswer = false;
            speakerIcon.classList.add('speaking');

            const utterance = new SpeechSynthesisUtterance(word);
            utterance.lang = 'en-US'; 
            utterance.rate = 0.8;     
            utterance.pitch = 1.1;    

            utterance.onend = () => {
                isSpeaking = false;
                canAnswer = true; 
                speakerIcon.classList.remove('speaking');
            };

            window.speechSynthesis.speak(utterance);
        }

        let particles = [];
        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 4; 
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vy += 0.1; 
                this.life -= this.decay;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class FlyingBubble {
            constructor(text, startX, colorTheme) {
                this.text = text;
                this.radius = 70; 
                this.x = startX;
                this.y = -this.radius * 2; 
                this.colorTheme = colorTheme; 
                this.color = colorTheme === 'blue' ? '#4facfe' : (colorTheme === 'pink' ? '#fe4f8a' : '#a64ffe');
                this.vy = Math.random() * 1.5 + 1.5; 
                this.vx = (Math.random() - 0.5) * 1; 
                this.pulse = Math.random() * Math.PI;
                this.isHit = false; 
            }

            update() {
                if (this.isHit) return; 
                this.y += this.vy;
                this.x += this.vx;
                if (this.x < this.radius || this.x > width - this.radius) {
                    this.vx *= -1;
                }
                this.pulse += 0.05;
            }

            draw() {
                if (this.isHit) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                const currentRadius = this.radius + Math.sin(this.pulse) * 3;

                ctx.shadowBlur = 25;
                ctx.shadowColor = this.color;

                const grad = ctx.createRadialGradient(0, 0, currentRadius * 0.5, 0, 0, currentRadius);
                grad.addColorStop(0, this.color);
                grad.addColorStop(1, adjustColorBrightness(this.color, -30));
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.ellipse(-currentRadius*0.3, -currentRadius*0.3, currentRadius*0.2, currentRadius*0.1, Math.PI/4, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.fill();

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.scale(-1, 1); 
                ctx.fillStyle = 'white';
                ctx.font = "bold 32px 'Fredoka', sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.shadowBlur = 5;
                ctx.shadowColor = 'black';
                ctx.fillText(this.text, 0, 0);

                ctx.restore();
            }
            
            isOffScreen() {
                return this.y > height + this.radius;
            }
        }

        function adjustColorBrightness(hex, percent) {
            let r = parseInt(hex.substring(1, 3), 16);
            let g = parseInt(hex.substring(3, 5), 16);
            let b = parseInt(hex.substring(5, 7), 16);
            r = parseInt(r * (100 + percent) / 100);
            g = parseInt(g * (100 + percent) / 100);
            b = parseInt(b * (100 + percent) / 100);
            r = (r<255)?r:255; g = (g<255)?g:255; b = (b<255)?b:255;
            const RR = ((r.toString(16).length==1)?"0"+r.toString(16):r.toString(16));
            const GG = ((g.toString(16).length==1)?"0"+g.toString(16):g.toString(16));
            const BB = ((b.toString(16).length==1)?"0"+b.toString(16):b.toString(16));
            return "#"+RR+GG+BB;
        }

        let bubbles = [];
        let questionTimer = null;

        function startNewQuestion() {
            if (!gameActive) return;
            const triplet = [...wordTriplets[Math.floor(Math.random() * wordTriplets.length)]];
            currentTargetWord = triplet[Math.floor(Math.random() * 3)];
            triplet.sort(() => Math.random() - 0.5);

            bubbles = [];
            const colors = ['blue', 'pink', 'purple'];
            for (let i = 0; i < 3; i++) {
                const startX = width * (0.25 * (i + 1)); 
                bubbles.push(new FlyingBubble(triplet[i], startX, colors[i]));
            }
            
            setTimeout(() => {
                speakWord(currentTargetWord);
            }, 500);

            clearTimeout(questionTimer);
            questionTimer = setTimeout(checkMissed, 6000); 
        }

        function checkMissed() {
            if (bubbles.length > 0 && gameActive) {
                streak = 0;
                updateUI();
                showFeedback("Missed!", width/2, height/2, '#ff5e62');
                playSound('wrong');
                bubbles = []; 
                setTimeout(startNewQuestion, 1500);
            }
        }

        function handleHit(bubble, handX, handY) {
            if (!canAnswer || bubble.isHit) return;

            bubble.isHit = true; 

            if (bubble.text === currentTargetWord) {
                createExplosion(handX, handY, '#00ffcc');
                score += 10 + streak * 2; 
                streak++;
                playSound('correct');
                showFeedback("Awesome!", handX, handY, '#00ffcc');
                
                clearTimeout(questionTimer);
                setTimeout(() => {
                    bubbles = [];
                    setTimeout(startNewQuestion, 1000);
                }, 500);

            } else {
                createExplosion(handX, handY, '#ff5e62');
                streak = 0;
                playSound('wrong');
                showFeedback("Oops!", handX, handY, '#ff5e62');
            }
            updateUI();
        }

        function playSound(type) {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            const actx = new AudioContext();
            const osc = actx.createOscillator();
            const gain = actx.createGain();
            osc.connect(gain);
            gain.connect(actx.destination);
            if (type === 'correct') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, actx.currentTime); osc.frequency.exponentialRampToValueAtTime(1400, actx.currentTime + 0.15);
                gain.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + 0.3);
            } else {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, actx.currentTime); osc.frequency.exponentialRampToValueAtTime(50, actx.currentTime + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + 0.2);
            }
            osc.start(); osc.stop(actx.currentTime + 0.3);
        }

        function createExplosion(x, y, color) {
            for(let i=0; i<40; i++) particles.push(new Particle(x, y, color));
        }
        
        let feedbackText = null;
        function showFeedback(text, x, y, color) {
            feedbackText = { x, y, text, color, life: 1.0, scale: 0.5 };
        }

        function updateUI() {
            scoreDisplay.innerText = `Score: ${score}`;
            streakDisplay.innerText = `Streak: ${streak}`;
        }

        function renderLoop() {
            ctx.clearRect(0, 0, width, height);
            
            for (let i = bubbles.length - 1; i >= 0; i--) {
                const b = bubbles[i];
                b.update();
                b.draw();
                if (b.isOffScreen() && !b.isHit) {
                    bubbles.splice(i, 1);
                }
            }

            if (bubbles.length === 0 && canAnswer && gameActive) {
                 clearTimeout(questionTimer);
                 checkMissed();
            }

            particles.forEach((p, idx) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(idx, 1); });

            if (feedbackText) {
                ctx.save();
                ctx.translate(feedbackText.x, feedbackText.y);
                ctx.scale(-feedbackText.scale, feedbackText.scale); 
                feedbackText.y -= 1.5; 
                feedbackText.life -= 0.02;
                feedbackText.scale = Math.min(1.2, feedbackText.scale + 0.1); 
                
                ctx.globalAlpha = Math.max(0, feedbackText.life);
                ctx.fillStyle = feedbackText.color;
                ctx.font = "900 40px 'Fredoka', sans-serif";
                ctx.textAlign = "center";
                ctx.shadowColor = feedbackText.color;
                ctx.shadowBlur = 15;
                ctx.fillText(feedbackText.text, 0, 0);
                ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.strokeText(feedbackText.text, 0, 0);
                
                ctx.restore();
                if (feedbackText.life <= 0) feedbackText = null;
            }
        }

        function onResults(results) {
            if (!gameActive) return;
            renderLoop(); 

            if (results.multiHandLandmarks) {
                for (const landmarks of results.multiHandLandmarks) {
                    const indexTip = landmarks[8]; 
                    const x = indexTip.x * width;
                    const y = indexTip.y * height;

                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, Math.PI*2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(x, y, 10, 0, Math.PI*2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.shadowColor = '#00f2fe'; ctx.shadowBlur = 15;
                    ctx.fill();
                    ctx.shadowBlur = 0;

                    if (canAnswer) {
                        bubbles.forEach(b => {
                            if (b.isHit) return;
                            const dx = x - b.x; const dy = y - b.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < b.radius + 10) {
                                handleHit(b, x, y);
                            }
                        });
                    }
                }
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        startBtn.addEventListener('click', async () => {
            // [ä¿®æ­£é‡é» 2] å¢åŠ éŒ¯èª¤æ•æ‰æ©Ÿåˆ¶ (try-catch)
            try {
                if ('speechSynthesis' in window === false) { alert("ä¸æ”¯æ´èªéŸ³åˆæˆ"); return; }
                
                startBtn.innerText = "Loading..."; 
                loadingText.innerText = "æ­£åœ¨å•Ÿå‹•æ”å½±æ©Ÿ...è«‹é»æ“Šã€Œå…è¨±ã€";
                
                width = window.innerWidth; height = window.innerHeight;
                canvasElement.width = width; canvasElement.height = height;

                const camera = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: 1280, height: 720
                });
                
                await camera.start(); // é€™è£¡å¯èƒ½æœƒå¤±æ•—ï¼ˆå¦‚æœæ¬Šé™è¢«æ‹’ï¼‰
                
                startScreen.style.opacity = 0;
                setTimeout(() => { startScreen.style.display = 'none'; }, 500);
                gameActive = true;
                startNewQuestion(); 
            } catch (error) {
                console.error(error);
                loadingText.innerText = "âŒ å•Ÿå‹•å¤±æ•—ï¼šè«‹æª¢æŸ¥æ”å½±æ©Ÿæ¬Šé™æˆ–ç¶²å€æ˜¯å¦ç‚º HTTPS";
                alert("ç„¡æ³•å•Ÿå‹•æ”å½±æ©Ÿï¼è«‹ç¢ºèªï¼š\n1. æ‚¨æ˜¯å¦æŒ‰ä¸‹äº†ã€Œå…è¨±ã€ä½¿ç”¨æ”å½±æ©Ÿã€‚\n2. è‹¥åœ¨é›»è…¦ä¸Šæ¸¬è©¦ï¼Œè«‹ç¢ºèªæ˜¯å¦ç‚º localhost æˆ– https ç¶²å€ã€‚");
            }
        });

        window.addEventListener('resize', () => {
            width = window.innerWidth; height = window.innerHeight;
            canvasElement.width = width; canvasElement.height = height;
        });
    </script>
</body>
</html>
